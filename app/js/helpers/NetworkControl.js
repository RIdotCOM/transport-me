'use strict'

const NetworkControl = (function() {
  const _object = {

    fetchFromNetwork(event) {
      console.log('network fetch')
      const url = event.request.url
      return fetch(url)
    }

  }

  return _object
}())

export default NetworkControl

// class CacheControl {

//   constructor( staticCache ) {
//     // code

//     let cachedContent = {
//       '/data': this.get.bind(this),
//       '/route': this.get.bind(this)
//     }

//     this.cacheName = staticCache

//     this.isCacheable = function(name, event) {
//       // console.log(name)
//       // console.log(typeof cachedContent[name])
//       // console.log(!!cachedContent[name])
//       // console.log(cachedContent[name])
//       // if ( cachedContent[name] ) {
//       //   // console.log('testing')
//       //   console.log(name)
//       // }
//       // console.log(this.get)
//       return cachedContent[name] && cachedContent[name]( event )
//     }
//   }

//   // we have the text file cached on the first time,
//   // then when requesting specific routes in the route namespace
//   // check if this request is already in the case
//   // if this request is not in the cache, build new response
//   // put this response in the cache and return the response

//   // say we have only 10 or so chaces responses in the required route namespace at
//   // any time, all else is being generated by returning the data from /data
//   // namespace, which is basically trips grouped by line name and day



//   // if the 
//   get ( event ) {
//     console.log('getting cache from', this.cacheName)
//     return event.respondWith(
//       caches.match(event.request).then((response) => {
//         console.log(response)
//         if (response && response.ok) {
//           console.log('Found response in cache:', response)
//           return response
//         }
//         console.log('No response found in cache. About to fetch from network...')

//         return fetch(event.request).then((res) => {
//           console.log(res)
//           if ( res ) {
//             console.log(res.clone())
//             this.putIntoCache( event, res.clone(), this.cacheName)

//             console.log('here is response', res)
//             return res
//           } else {

//             // response is not OK at all
//             // return new custom bullshit response

//           }          

//           // return res
//         }).catch((error) => {
//           console.error('Fetching failed:', error)
//           throw error
//         })
//       })
//     )
//   }

//   getFromCache(event, callback) {
//     return event.respondWith(
//       caches.match(event.request).then((response) => {
//         console.log(response)
//         if (response && response.ok) {
//           console.log('Found response in cache:', response)
//           return response
//         }
//         console.log('No response found in cache. About to fetch from network...')

//         callback()

//         // return fetch(event.request).then((res) => {
//         //   console.log(res)
//         //   if ( res ) {
//         //     console.log(res.clone())
//         //     this.putIntoCache( event, res.clone(), this.cacheName)

//         //     console.log('here is response', res)
//         //     return res
//         //   } else {

//         //     // response is not OK at all
//         //     // return new custom bullshit response

//         //   }          

//         //   // return res
//         // }).catch((error) => {
//         //   console.error('Fetching failed:', error)
//         //   throw error
//         // })
//       })
//     )
//   }

//   putIntoCache(event, clonedResponse, cacheName) {
//     caches.open(cacheName).then((cache) => {
//       console.log('Putting response in in Cache')
//       cache.put(event.request, clonedResponse)
//     }).catch(err => {
//       console.error('Putting into Cache failed:', err)
//       throw err
//     })
//   }
//   // methods
// }
